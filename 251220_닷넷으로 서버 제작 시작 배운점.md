## 📘 TIL – Server

### 📅 2025.12.20 (251220)

### 오늘의 한 줄 요약

> 게임 서버 구현을 시작하며, **엔진 의존 데이터(SO / Godot Resource)가 없는 환경에서 왜 `sealed record` 기반의 순수 데이터 모델을 쓰는지**를 개념부터 정리했다.

---

## 🔍 오늘 다룬 주제

* 서버 환경에서의 데이터 모델링
* Unity / Godot 엔진 데이터와 서버 데이터의 근본적 차이
* `sealed record` 사용 이유
* record 내부에 **객체 참조를 두지 않는 이유**

---

## 🧠 큰 전제 정리 (이걸 잊지 말 것)

### 서버에는 이것들이 **없다**

* ScriptableObject ❌
* Godot Resource ❌
* Inspector ❌
* Scene / Node ❌

서버는:

> **오직 “데이터와 규칙”만 존재하는 세계**

그래서 서버 코드는
“에디터 친화적”이 아니라
**“기계 친화적 · 검증 친화적”이어야 한다.

---

## 1️⃣ 왜 서버에선 ScriptableObject 같은 게 없는가

Unity / Godot의 SO / Resource는:

* 에디터에서 수정
* 런타임에 참조
* 디자이너 친화적

하지만 서버는:

* 에디터가 없음
* 런타임 중 데이터 변경을 극도로 싫어함
* **재현 가능성 / 직렬화 / 검증**이 최우선

👉 그래서 서버는
**“데이터 = 코드로 정의된 구조”**를 택함

---

## 2️⃣ `record`를 쓰는 이유

```csharp
public sealed record CardEffectDef(
    string Id,
    int Cost,
    int Power
);
```

### record의 핵심 성질

* **불변(immutable)** 기본값
* 값 기반 비교 (reference가 아니라 value)
* 직렬화 / 로그 / 테스트에 매우 유리

서버에서 중요한 건:

* “이 객체가 같은 인스턴스냐?” ❌
* “이 데이터가 같은 값이냐?” ✅

👉 record는 서버 세계관에 딱 맞음

---

## 3️⃣ 왜 `sealed record`인가

### ❌ 상속 가능한 record의 문제

* 누가 어디서 구조를 바꿨는지 추적 어려움
* 직렬화 시 타입 분기 증가
* 규칙 검증 복잡도 폭증

### ✅ sealed record의 의미

```csharp
public sealed record EffectNode(...)
```

* **이 데이터 구조는 여기서 끝**
* 서버 규칙이 예측 가능
* “이 타입은 이렇게 생겼다”가 고정됨

👉 서버에선
**확장성보다 안정성이 우선**

확장은:

* 새 타입 추가
* 새 record 정의
  로 해결해야 함

---

## 4️⃣ sealed record 안에 “객체”를 안 넣는 이유 (중요)

### ❌ 이렇게 하면 위험

```csharp
public sealed record Card(
    string Id,
    EffectResolver Resolver   // ❌
);
```

이유는 명확함.

#### 1. 직렬화 불가능 / 불안정

* 함수
* 서비스 객체
* 상태 가진 클래스

이건:

* JSON으로 안 깨끗하게 떨어짐
* 네트워크 전송 불가
* 로그 재현 불가

---

#### 2. 서버 데이터는 “상태”가 없어야 함

record는:

> “정의(definition)” 여야지
> “행위(behavior)”를 가지면 안 됨

행위는:

* 시스템
* 엔진
* 해석기

쪽에 있어야 함

---

### ✅ 올바른 서버 구조 사고

```text
[정의 데이터]
sealed record CardEffectDef

[해석 / 실행]
EffectResolver
EffectRunner
```

* 데이터는 **순수**
* 로직은 **외부**

이렇게 분리해야:

* 테스트 가능
* 리플레이 가능
* 치트 검증 가능

---

## 5️⃣ Unity / Godot 경험자에게 헷갈리는 지점

Unity에선 자연스럽게:

* SO 안에 로직 넣고
* 메서드 호출하고
* 런타임 객체를 들고 다님

서버에선 그 순간:

> ❌ “이건 서버가 아니라 클라이언트 사고다”

서버는:

* “이 데이터가 **무엇을 의미하는지**”
* “이 규칙이 **항상 같은 결과를 내는지**”
  만 중요

---

## 💡 오늘의 핵심 통찰 (나중에 꼭 다시 읽기)

* 서버는 **엔진이 아니다**
* 서버 데이터는 **순수하고, 불변이며, 해석 대상**
* `sealed record`는:

  * SO / Resource의 “서버 버전”
  * 하지만 **행위 없는 선언체**

> 서버에서 “왜 이렇게까지 딱딱하게 짜지?”라는 의문이 들면
> 그건 서버를 제대로 만들고 있다는 신호다.

---

## 📌 다음에 할 것 (TODO)

* [ ] record 기반 데이터 정의 더 늘려보기
* [ ] “정의 데이터 vs 실행 로직” 분리 연습
* [ ] 서버 규칙을 로그로 재현하는 상상 실험
